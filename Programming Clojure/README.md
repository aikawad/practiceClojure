Programming Clojure
===

##Table of Content ###

- Getting Started
- Exploring Clojure
- Unifying Data with Sequences
- Functional Programming
- State
- Protocols and Datatypes
- Macros
- Multimethods
- Java Down and Dirty
- Building an Application


---
##### Getting Started
- Why Clojure?
- Clojure Coding Quick Start
- Exploreing Clojure Libraries
- Wrapping Up

---
#####  Exploring Clojure

- Forms
- REader Macros
- Functins
- Vars, Bindings, and Namespaces
- Calling Java
- Flow Control
- Where's My for Loop?
- Metadata
- Wrapping Up

---
##### Unifying Data with Sequences
- Everything Is a Sequence
- Using the Sequence Library
- Lazy and Infinite Sequences
- Clojure Makes Java Seq-able
- Calling Structure-Specific Functions
- Wrapping Up

---
##### Functional Programming
- Functional Programming Concepts
- How to Be Lazy
- Lazier Than Lazy
- Recursion Revisited
- Wrapping Up

---
#####  State
- Concurrency, Parallelism, and Locking
- Refs and Software Transactinal Memory
- Use Atoms for Uncoordinated, Synchronous Updates
- Use Agents for Asynchronous Updates
- Managing Per-Thread State with Vars
- A Clojure Snake
- Wrapping Up

---
##### Protocols and Datatypes
- Programming to Abstractions
- Interfaces
- Protocols
- Datatypes
- Records
- reify
- Wrapping Up

---
##### Macros
- When to Use Macros
- Writing a Control Flow Macro
- Making Macros Simpler
- Taxonomy of Macros
- Wrapping Up

---
##### Multimethods
- Living Without Multimethods
- Defining Multimethods
- Moving Beyond Simple Dispatch
- Creating Ad Hoc Taxonomies
- When Should I Use Multimethods?
- Wrapping Up

---
##### Java Down and Dirty
- Exception Handling
- Wrestling with the Integers
- Optimizing for Performance
- Creating Java Classes in Clojure
- A Real-World Example
- Wrapping Up

---
##### Building an Application
- Scoring a Clojurebreaker Game
- Testing the Scorer
- test.generative
- Creating an Interface
- Deploying Your Code
- Farewell

---